{
  "version": 3,
  "sources": [],
  "sections": [
    {"offset": {"line": 58, "column": 0}, "map": {"version":3,"sources":["file:///Users/abdulfataiojetimi/hellosolar/src/lib/documents.ts"],"sourcesContent":["import fs from 'fs';\nimport path from 'path';\n\ninterface Document {\n  id: string;\n  title: string;\n  category: string;\n  content: string;\n  filepath: string;\n}\n\ninterface SearchResult {\n  document: Document;\n  score: number;\n}\n\n// Get the project root directory\nconst getProjectRoot = () => {\n  return path.join(process.cwd());\n};\n\n// Read all markdown files from solar_docs recursively\nexport async function getAllDocuments(): Promise<Document[]> {\n  const documents: Document[] = [];\n  const solarDocsPath = path.join(getProjectRoot(), 'src/solar_docs');\n\n  if (!fs.existsSync(solarDocsPath)) {\n    console.warn('solar_docs directory not found');\n    return documents;\n  }\n\n  function scanDirectory(dir: string, category: string = '') {\n    const files = fs.readdirSync(dir);\n\n    for (const file of files) {\n      const fullPath = path.join(dir, file);\n      const stat = fs.statSync(fullPath);\n\n      if (stat.isDirectory()) {\n        // Recurse into subdirectory with updated category\n        const newCategory = category ? `${category}/${file}` : file;\n        scanDirectory(fullPath, newCategory);\n      } else if (file.endsWith('.md')) {\n        // Read markdown file\n        const content = fs.readFileSync(fullPath, 'utf-8');\n        \n        // Extract title from first line (remove # prefix)\n        const titleMatch = content.match(/^#\\s+(.+)$/m);\n        const title = titleMatch ? titleMatch[1] : file.replace('.md', '');\n\n        const doc: Document = {\n          id: `${category}/${file}`.replace('.md', ''),\n          title,\n          category,\n          content,\n          filepath: fullPath,\n        };\n\n        documents.push(doc);\n      }\n    }\n  }\n\n  scanDirectory(solarDocsPath);\n  return documents;\n}\n\n// Simple keyword-based search for relevant documents\nexport async function searchDocuments(query: string, documents?: Document[]): Promise<SearchResult[]> {\n  const docs = documents || await getAllDocuments();\n  const queryLower = query.toLowerCase();\n  \n  // Split query into keywords\n  const keywords = queryLower.split(/\\s+/).filter(k => k.length > 2);\n\n  const results: SearchResult[] = docs.map(doc => {\n    const contentLower = doc.content.toLowerCase();\n    const titleLower = doc.title.toLowerCase();\n    const categoryLower = doc.category.toLowerCase();\n\n    let score = 0;\n\n    // Title matches are worth more\n    for (const keyword of keywords) {\n      if (titleLower.includes(keyword)) score += 10;\n      if (categoryLower.includes(keyword)) score += 5;\n      \n      // Count occurrences in content\n      const matches = (contentLower.match(new RegExp(keyword, 'g')) || []).length;\n      score += Math.min(matches, 10); // Cap at 10 occurrences per keyword\n    }\n\n    return {\n      document: doc,\n      score,\n    };\n  });\n\n  // Filter out zero scores and sort by relevance\n  return results\n    .filter(r => r.score > 0)\n    .sort((a, b) => b.score - a.score)\n    .slice(0, 5); // Return top 5 results\n}\n\n// Get context from top relevant documents\nexport async function getContextForQuery(query: string, maxLength: number = 8000): Promise<string> {\n  const results = await searchDocuments(query);\n  \n  if (results.length === 0) {\n    return '';\n  }\n\n  // Combine content from top documents\n  let context = '';\n  \n  for (const result of results) {\n    const doc = result.document;\n    // Remove the title line from content for context\n    const cleanContent = doc.content.replace(/^#\\s+.+\\n\\n/, '');\n    \n    context += `=== ${doc.title} (${doc.category}) ===\\n`;\n    context += cleanContent + '\\n\\n';\n    \n    if (context.length > maxLength) {\n      break;\n    }\n  }\n\n  return context;\n}\n\n// Get document by ID\nexport async function getDocumentById(id: string): Promise<Document | null> {\n  const documents = await getAllDocuments();\n  return documents.find(doc => doc.id === id) || null;\n}\n\n// Get all categories\nexport async function getAllCategories(): Promise<string[]> {\n  const documents = await getAllDocuments();\n  const categories = new Set(documents.map(doc => doc.category));\n  return Array.from(categories).sort();\n}\n\n"],"names":[],"mappings":"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"}},
    {"offset": {"line": 172, "column": 0}, "map": {"version":3,"sources":["file:///Users/abdulfataiojetimi/hellosolar/src/app/api/ask/route.ts"],"sourcesContent":["import { NextResponse } from 'next/server'\nimport { getContextForQuery, searchDocuments } from '@/lib/documents'\n\ninterface Document {\n  id: string;\n  title: string;\n  category: string;\n  content: string;\n  filepath: string;\n}\n\ninterface SearchResult {\n  document: Document;\n  score: number;\n}\n\nfunction formatDocumentContent(content: string): string {\n  // Clean up markdown content and format it nicely\n  // Remove the title line (starts with #)\n  let formatted = content.replace(/^#\\s+.+\\n\\n/, '');\n  \n  // Convert markdown headers to formatted text\n  formatted = formatted.replace(/^###\\s+(.+)$/gm, '\\nðŸ’¡ $1\\n');\n  formatted = formatted.replace(/^##\\s+(.+)$/gm, '\\nðŸ“‹ $1\\n');\n  \n  // Convert bold text\n  formatted = formatted.replace(/\\*\\*([^*]+)\\*\\*/g, '$1');\n  \n  // Convert lists\n  formatted = formatted.replace(/^[-*]\\s+/gm, 'â€¢ ');\n  \n  // Clean up extra whitespace\n  formatted = formatted.replace(/\\n{3,}/g, '\\n\\n');\n  \n  return formatted.trim();\n}\n\nfunction extractAnswerFromContext(context: string, question: string): string {\n  // Simple keyword-based answer extraction from context\n  const questionLower = question.toLowerCase();\n  const lines = context.split('\\n');\n  \n  // Keywords that might indicate relevant content\n  const keywords = questionLower.split(/\\s+/).filter(k => k.length > 2);\n  \n  // Find lines containing question keywords\n  const relevantLines: string[] = [];\n  \n  for (const line of lines) {\n    const lineLower = line.toLowerCase();\n    for (const keyword of keywords) {\n      if (lineLower.includes(keyword) && line.length > 10) {\n        relevantLines.push(line.trim());\n        break;\n      }\n    }\n  }\n  \n  // If we found relevant lines, return them as a formatted answer\n  if (relevantLines.length > 0) {\n    // Remove duplicates\n    const uniqueLines = [...new Set(relevantLines)];\n    return uniqueLines.slice(0, 5).join('\\n\\n');\n  }\n  \n  return '';\n}\n\nexport async function POST(req: Request) {\n  try {\n    const { question } = await req.json()\n\n    if (!question) {\n      return NextResponse.json({ error: 'Question is required' }, { status: 400 })\n    }\n\n    // Get relevant context from solar documents\n    const context = await getContextForQuery(question)\n    \n    // Also get search results for more detailed information\n    const searchResults = await searchDocuments(question)\n\n    let answer: string\n\n    if (context && searchResults.length > 0) {\n      // Build a comprehensive answer from the documents\n      const topResults = searchResults.slice(0, 3)\n      \n      answer = `Based on our knowledge base, here's information about \"${question}\":\\n\\n`\n      \n      for (const result of topResults) {\n        const doc = result.document\n        answer += `â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”\\n`\n        answer += `ðŸ“„ ${doc.title}\\n`\n        answer += `ðŸ“ Category: ${doc.category.replace('/', ' > ')}\\n`\n        answer += `â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”\\n\\n`\n        \n        const formattedContent = formatDocumentContent(doc.content)\n        answer += `${formattedContent}\\n\\n`\n      }\n      \n      // Try to extract a direct answer from the context\n      const directAnswer = extractAnswerFromContext(context, question)\n      if (directAnswer) {\n        answer = `ðŸ’¬ **Quick Answer:**\\n${directAnswer}\\n\\n---\\n\\nðŸ“š **More Details:**\\n\\n${answer}`\n      }\n    } else if (context) {\n      // Just use the context if no search results\n      const formattedContext = formatDocumentContent(context)\n      answer = `Here's what I found in our knowledge base:\\n\\n${formattedContext}`\n    } else {\n      // No documents found - provide a general helpful response\n      answer = `I couldn't find specific information about \"${question}\" in our knowledge base. However, I can help you with general solar energy questions. Please try rephrasing your question or ask about:\\n\\nâ€¢ Solar panels (types, installation, issues)\\nâ€¢ Inverters (basics, types, troubleshooting)\\nâ€¢ Batteries (types, maintenance, issues)\\nâ€¢ General solar energy questions\\nâ€¢ Installation and troubleshooting`\n    }\n\n    // Clean up the answer\n    answer = answer.trim()\n    \n    // If answer is too long, truncate it nicely\n    if (answer.length > 3000) {\n      answer = answer.substring(0, 3000) + '\\n\\n... (answer truncated for length)'\n    }\n\n    return NextResponse.json({ answer })\n  } catch (error) {\n    console.error('Error in ask API:', error)\n    return NextResponse.json({ error: 'Failed to process your request. Please try again.' }, { status: 500 })\n  }\n}\n\n"],"names":[],"mappings":"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"}}]
}